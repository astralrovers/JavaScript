var o = {
    then : function(){}
};

var j = Object.create(o);

console.log(j.__proto__);
var v = new Promise(function(resolve, reject){
    /* 当创建一个一个Promise后，这个函数会同步或者立即执行，
     * 可以说这里就是现在
     * */
    console.log("hello"); // 假设是一个异步操作，
                            // 即使是已经完成了，那么也不会立马就执行回调
                            // 进行决议处理。
    resolve("ok");          // 将来，我们自己定义的失败或成功会掉函数，
                            // 只有在调用then之后才会调用
    // 这里的实现时候和事件循环有关
});
function out_time(time) {
    return new Promise(function(resolve, reject){
        setTimeout(function(){
            resolve("超时:" + time);
        }, time);
    });
}

/* race并不是说谁先完成了，剩下的回调就会被中断，不执行了，
 * 只是说不会在被Promise处理，即只有一个未来值会被处理，其他的会被忽略
 * */
out_time(4000).then(// 这里就是将来我们自己可以控制的
                                        // 反转的反转，拿到异步后的结果，
    // 我们再决定失败或成功如何处理
function(data){
    console.log(data);
    return out_time(3000);
},
function(data){
    console.log(data);
}).then((data)=>{
    console.log(data);
});
out_time(2000).then((data)=>{
    console.log(data);
});
console.log("end");// 看看打印结果，then并不是立即执行的，而是异步执行的
// then被调用后添加到了异步任务里
/*
 * js异步和同步的实现
 * 异步任务和同步任务时在两个不同的线程(或者类似线程)内的，
 * 同步线程是用户线程(也就是js单线程)，异步线程是用户处理异步代码的
 * 因为js底层是c/c++实现的，所以线程可能是在多个处理器上同时执行，
 * 也可能是在单核处理器上以时间片轮转的方式执行，那么存在同步线程和异步
 * 线程交替执行的情况。
 * 异步线程内存在事件循环，在时间间隔的控制下挨个执行，并且是先入先出，
 * 异步任务像是一个队列，池子，被添加到里面的异步任务挨个轮询，当一个异步任务
 * 完成后，就会调用它的回调函数，至于每个异步任务的回调函数是如何管理的，
 * 不是清楚，要么是在每个异步任务内，要么是当一个异步任务完成后，被添加
 * 到一个回调函数池，仍然挨个执行(但是回调函数又像是回到了同步线程内，除非
 * 它又添加了异步任务)
 * 更像后者，因为如果一个异步任务完成后，剩余有时间去处理回调函数，而回调函数的
 * 处理时间却不够，而下一个任务恰好也完成了，但是他的回调函数处理时间够了，
 * 似乎异步任务不满足先入先出的规则(谁先完成，谁先处理)
 * */
